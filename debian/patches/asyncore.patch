--- a/spambayes/Dibbler.py	2011-01-22 16:15:06.000000000 +0100
+++ b/spambayes/Dibbler.py	2017-10-07 10:05:26.280110961 +0200
@@ -185,46 +185,6 @@
 from spambayes.port import md5
 from spambayes import asyncore, asynchat
 
-class BrighterAsyncChat(asynchat.async_chat):
-    """An asynchat.async_chat that doesn't give spurious warnings on
-    receiving an incoming connection, lets SystemExit cause an exit, can
-    flush its output, and will correctly remove itself from a non-default
-    socket map on `close()`."""
-
-    def __init__(self, conn=None, map=None):
-        """See `asynchat.async_chat`."""
-        asynchat.async_chat.__init__(self, conn)
-        self.__map = map
-        self._closed = False
-
-    def handle_connect(self):
-        """Suppresses the asyncore "unhandled connect event" warning."""
-        pass
-
-    def handle_error(self):
-        """Let SystemExit cause an exit."""
-        type, v, t = sys.exc_info()
-        if type == SystemExit:
-            raise
-        else:
-            asynchat.async_chat.handle_error(self)
-
-    def flush(self):
-        """Flush everything in the output buffer."""
-        # We check self._closed here because of the case where
-        # self.initiate_send() raises an exception, causing self.close()
-        # to be called.  If we didn't check, we could end up in an infinite
-        # loop.
-        while (self.producer_fifo or self.ac_out_buffer) and not self._closed:
-            self.initiate_send()
-
-    def close(self):
-        """Remove this object from the correct socket map."""
-        self._closed = True
-        self.del_channel(self.__map)
-        self.socket.close()
-
-
 class Context:
     """See the main documentation for details of `Dibbler.Context`."""
     def __init__(self, asyncMap=asyncore.socket_map):
@@ -355,7 +315,7 @@
         return "You must log in."
 
 
-class _HTTPHandler(BrighterAsyncChat):
+class _HTTPHandler(asynchat.async_chat):
     """This is a helper for the HTTP server class - one of these is created
     for each incoming request, and does the job of decoding the HTTP traffic
     and driving the plugins."""
@@ -367,8 +327,7 @@
     def __init__(self, clientSocket, server, context):
         # Grumble: asynchat.__init__ doesn't take a 'map' argument,
         # hence the two-stage construction.
-        BrighterAsyncChat.__init__(self, map=context._map)
-        BrighterAsyncChat.set_socket(self, clientSocket, context._map)
+        asynchat.async_chat.__init__(self, clientSocket, context._map)
         self._context = context
         self._server = server
         self._request = ''
